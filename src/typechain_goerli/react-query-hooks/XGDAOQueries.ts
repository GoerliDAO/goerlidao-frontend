/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BigNumber, BigNumberish, ContractReceipt } from "ethers";

import { XGDAO__factory } from "../factories/xGDAOERC20.sol";
import { useProvider, useSigner } from "wagmi";
import { useQuery, useMutation } from "@tanstack/react-query";

export default class XGDAOQueries {
  readonly contractAddress: string;
  readonly networkId?: { chainId: number };

  constructor(contractAddress: string, networkId?: number) {
    this.networkId = networkId ? { chainId: networkId } : undefined;
    this.contractAddress = contractAddress;
  }

  useAllowance = (owner: string, spender: string) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["allowance", "XGDAO", owner, spender], async () => {
      return await contract.allowance(owner, spender);
    });
  };

  useApprove = (spender: string, amount: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { spender: string; amount: BigNumberish }>({
      onMutate: async ({ spender, amount }) => {
        const transaction = await contract.approve(spender, amount);
        return transaction.wait();
      },
    });
  };

  useApproved = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["approved", "XGDAO"], async () => {
      return await contract.approved();
    });
  };

  useBalanceFrom = (_amount: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["balanceFrom", "XGDAO", _amount], async () => {
      return await contract.balanceFrom(_amount);
    });
  };

  useBalanceOf = (account: string) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["balanceOf", "XGDAO", account], async () => {
      return await contract.balanceOf(account);
    });
  };

  useBalanceTo = (_amount: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["balanceTo", "XGDAO", _amount], async () => {
      return await contract.balanceTo(_amount);
    });
  };

  useBurn = (_from: string, _amount: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { _from: string; _amount: BigNumberish }>({
      onMutate: async ({ _from, _amount }) => {
        const transaction = await contract.burn(_from, _amount);
        return transaction.wait();
      },
    });
  };

  useCheckpoints = (arg0: string, arg1: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<[BigNumber, BigNumber] & { fromBlock: BigNumber; votes: BigNumber }>(
      ["checkpoints", "XGDAO", arg0, arg1],
      async () => {
        return await contract.checkpoints(arg0, arg1);
      },
    );
  };

  useDecimals = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<number>(["decimals", "XGDAO"], async () => {
      return await contract.decimals();
    });
  };

  useDecreaseAllowance = (spender: string, subtractedValue: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { spender: string; subtractedValue: BigNumberish }>({
      onMutate: async ({ spender, subtractedValue }) => {
        const transaction = await contract.decreaseAllowance(spender, subtractedValue);
        return transaction.wait();
      },
    });
  };

  useDelegate = (delegatee: string) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { delegatee: string }>({
      onMutate: async ({ delegatee }) => {
        const transaction = await contract.delegate(delegatee);
        return transaction.wait();
      },
    });
  };

  useDelegates = (arg0: string) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["delegates", "XGDAO", arg0], async () => {
      return await contract.delegates(arg0);
    });
  };

  useGetCurrentVotes = (account: string) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["getCurrentVotes", "XGDAO", account], async () => {
      return await contract.getCurrentVotes(account);
    });
  };

  useGetPriorVotes = (account: string, blockNumber: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["getPriorVotes", "XGDAO", account, blockNumber], async () => {
      return await contract.getPriorVotes(account, blockNumber);
    });
  };

  useIncreaseAllowance = (spender: string, addedValue: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { spender: string; addedValue: BigNumberish }>({
      onMutate: async ({ spender, addedValue }) => {
        const transaction = await contract.increaseAllowance(spender, addedValue);
        return transaction.wait();
      },
    });
  };

  useIndex = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["index", "XGDAO"], async () => {
      return await contract.index();
    });
  };

  useMigrate = (_staking: string, _sGDAO: string) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { _staking: string; _sGDAO: string }>({
      onMutate: async ({ _staking, _sGDAO }) => {
        const transaction = await contract.migrate(_staking, _sGDAO);
        return transaction.wait();
      },
    });
  };

  useMigrated = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<boolean>(["migrated", "XGDAO"], async () => {
      return await contract.migrated();
    });
  };

  useMint = (_to: string, _amount: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { _to: string; _amount: BigNumberish }>({
      onMutate: async ({ _to, _amount }) => {
        const transaction = await contract.mint(_to, _amount);
        return transaction.wait();
      },
    });
  };

  useName = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["name", "XGDAO"], async () => {
      return await contract.name();
    });
  };

  useNumCheckpoints = (arg0: string) => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["numCheckpoints", "XGDAO", arg0], async () => {
      return await contract.numCheckpoints(arg0);
    });
  };

  useSGDAO = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["sGDAO", "XGDAO"], async () => {
      return await contract.sGDAO();
    });
  };

  useSymbol = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["symbol", "XGDAO"], async () => {
      return await contract.symbol();
    });
  };

  useTotalSupply = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["totalSupply", "XGDAO"], async () => {
      return await contract.totalSupply();
    });
  };

  useTransfer = (recipient: string, amount: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { recipient: string; amount: BigNumberish }>({
      onMutate: async ({ recipient, amount }) => {
        const transaction = await contract.transfer(recipient, amount);
        return transaction.wait();
      },
    });
  };

  useTransferFrom = (sender: string, recipient: string, amount: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = XGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { sender: string; recipient: string; amount: BigNumberish }>({
      onMutate: async ({ sender, recipient, amount }) => {
        const transaction = await contract.transferFrom(sender, recipient, amount);
        return transaction.wait();
      },
    });
  };

  useXGDAO = () => {
    const provider = useProvider(this.networkId);
    const contract = XGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["xGDAO", "XGDAO"], async () => {
      return await contract.xGDAO();
    });
  };
}
