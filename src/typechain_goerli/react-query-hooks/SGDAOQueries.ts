/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BigNumber, BigNumberish, BytesLike, ContractReceipt } from "ethers";

import { SGDAO__factory } from "../factories/sGDAO.sol";
import { useProvider, useSigner } from "wagmi";
import { useQuery, useMutation } from "@tanstack/react-query";

export default class SGDAOQueries {
  readonly contractAddress: string;
  readonly networkId?: { chainId: number };

  constructor(contractAddress: string, networkId?: number) {
    this.networkId = networkId ? { chainId: networkId } : undefined;
    this.contractAddress = contractAddress;
  }

  useDOMAIN_SEPARATOR = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["DOMAIN_SEPARATOR", "SGDAO"], async () => {
      return await contract.DOMAIN_SEPARATOR();
    });
  };

  useAllowance = (owner_: string, spender: string) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["allowance", "SGDAO", owner_, spender], async () => {
      return await contract.allowance(owner_, spender);
    });
  };

  useApprove = (spender: string, value: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { spender: string; value: BigNumberish }>({
      onMutate: async ({ spender, value }) => {
        const transaction = await contract.approve(spender, value);
        return transaction.wait();
      },
    });
  };

  useBalanceForGons = (gons: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["balanceForGons", "SGDAO", gons], async () => {
      return await contract.balanceForGons(gons);
    });
  };

  useBalanceOf = (who: string) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["balanceOf", "SGDAO", who], async () => {
      return await contract.balanceOf(who);
    });
  };

  useChangeDebt = (amount: BigNumberish, debtor: string, add: boolean) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { amount: BigNumberish; debtor: string; add: boolean }>({
      onMutate: async ({ amount, debtor, add }) => {
        const transaction = await contract.changeDebt(amount, debtor, add);
        return transaction.wait();
      },
    });
  };

  useCirculatingSupply = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["circulatingSupply", "SGDAO"], async () => {
      return await contract.circulatingSupply();
    });
  };

  useDebtBalances = (arg0: string) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["debtBalances", "SGDAO", arg0], async () => {
      return await contract.debtBalances(arg0);
    });
  };

  useDecimals = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<number>(["decimals", "SGDAO"], async () => {
      return await contract.decimals();
    });
  };

  useDecreaseAllowance = (spender: string, subtractedValue: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { spender: string; subtractedValue: BigNumberish }>({
      onMutate: async ({ spender, subtractedValue }) => {
        const transaction = await contract.decreaseAllowance(spender, subtractedValue);
        return transaction.wait();
      },
    });
  };

  useFromG = (amount: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["fromG", "SGDAO", amount], async () => {
      return await contract.fromG(amount);
    });
  };

  useGonsForBalance = (amount: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["gonsForBalance", "SGDAO", amount], async () => {
      return await contract.gonsForBalance(amount);
    });
  };

  useIncreaseAllowance = (spender: string, addedValue: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { spender: string; addedValue: BigNumberish }>({
      onMutate: async ({ spender, addedValue }) => {
        const transaction = await contract.increaseAllowance(spender, addedValue);
        return transaction.wait();
      },
    });
  };

  useIndex = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["index", "SGDAO"], async () => {
      return await contract.index();
    });
  };

  useInitialize = (_stakingContract: string, _treasury: string) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { _stakingContract: string; _treasury: string }>({
      onMutate: async ({ _stakingContract, _treasury }) => {
        const transaction = await contract.initialize(_stakingContract, _treasury);
        return transaction.wait();
      },
    });
  };

  useName = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["name", "SGDAO"], async () => {
      return await contract.name();
    });
  };

  useNonces = (owner: string) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["nonces", "SGDAO", owner], async () => {
      return await contract.nonces(owner);
    });
  };

  usePermit = (
    owner: string,
    spender: string,
    value: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
  ) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<
      ContractReceipt,
      Error,
      {
        owner: string;
        spender: string;
        value: BigNumberish;
        deadline: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }
    >({
      onMutate: async ({ owner, spender, value, deadline, v, r, s }) => {
        const transaction = await contract.permit(owner, spender, value, deadline, v, r, s);
        return transaction.wait();
      },
    });
  };

  useRebase = (profit_: BigNumberish, epoch_: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { profit_: BigNumberish; epoch_: BigNumberish }>({
      onMutate: async ({ profit_, epoch_ }) => {
        const transaction = await contract.rebase(profit_, epoch_);
        return transaction.wait();
      },
    });
  };

  useRebases = (arg0: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        epoch: BigNumber;
        rebase: BigNumber;
        totalStakedBefore: BigNumber;
        totalStakedAfter: BigNumber;
        amountRebased: BigNumber;
        index: BigNumber;
        blockNumberOccured: BigNumber;
      }
    >(["rebases", "SGDAO", arg0], async () => {
      return await contract.rebases(arg0);
    });
  };

  useSetIndex = (_index: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { _index: BigNumberish }>({
      onMutate: async ({ _index }) => {
        const transaction = await contract.setIndex(_index);
        return transaction.wait();
      },
    });
  };

  useSetxGDAO = (_xGDAO: string) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { _xGDAO: string }>({
      onMutate: async ({ _xGDAO }) => {
        const transaction = await contract.setxGDAO(_xGDAO);
        return transaction.wait();
      },
    });
  };

  useStakingContract = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["stakingContract", "SGDAO"], async () => {
      return await contract.stakingContract();
    });
  };

  useSymbol = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["symbol", "SGDAO"], async () => {
      return await contract.symbol();
    });
  };

  useToG = (amount: BigNumberish) => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["toG", "SGDAO", amount], async () => {
      return await contract.toG(amount);
    });
  };

  useTotalSupply = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<BigNumber>(["totalSupply", "SGDAO"], async () => {
      return await contract.totalSupply();
    });
  };

  useTransfer = (to: string, value: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { to: string; value: BigNumberish }>({
      onMutate: async ({ to, value }) => {
        const transaction = await contract.transfer(to, value);
        return transaction.wait();
      },
    });
  };

  useTransferFrom = (from: string, to: string, value: BigNumberish) => {
    const { data: signer } = useSigner();
    if (!signer) throw new Error("Signer is not set");
    const contract = SGDAO__factory.connect(this.contractAddress, signer);
    return useMutation<ContractReceipt, Error, { from: string; to: string; value: BigNumberish }>({
      onMutate: async ({ from, to, value }) => {
        const transaction = await contract.transferFrom(from, to, value);
        return transaction.wait();
      },
    });
  };

  useTreasury = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["treasury", "SGDAO"], async () => {
      return await contract.treasury();
    });
  };

  useXGDAO = () => {
    const provider = useProvider(this.networkId);
    const contract = SGDAO__factory.connect(this.contractAddress, provider);
    return useQuery<string>(["xGDAO", "SGDAO"], async () => {
      return await contract.xGDAO();
    });
  };
}
